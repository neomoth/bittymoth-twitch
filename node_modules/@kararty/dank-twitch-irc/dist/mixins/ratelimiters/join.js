"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JoinRateLimiter = void 0;
const semaphore_async_await_1 = require("semaphore-async-await");
const apply_function_replacements_1 = require("../../utils/apply-function-replacements");
class JoinRateLimiter {
    client;
    joinLimitsSemaphore;
    constructor(client) {
        this.client = client;
        this.joinLimitsSemaphore = new semaphore_async_await_1.default(this.client.configuration.rateLimits.joinLimits);
    }
    applyToClient(client) {
        const joinReplacement = async (oldFn, channelName, ...args) => {
            const releaseFn = await this.acquire();
            try {
                return await oldFn(channelName, ...args);
            }
            finally {
                setTimeout(releaseFn, 10 * 1000); // 10 seconds per 20 joined channels.
            }
        };
        const joinAllReplacement = async (oldFn, channelNames, ...args) => {
            const promiseResults = [];
            for (let i = 0; i < channelNames.length; i += this.client.configuration.rateLimits.joinLimits) {
                const chunk = channelNames.slice(i, i + this.client.configuration.rateLimits.joinLimits);
                const releaseFns = await Promise.all(Array(chunk.length)
                    .fill(this.acquire)
                    .map((fn) => fn.bind(this)()));
                try {
                    const promiseRes = await oldFn(chunk, ...args);
                    promiseResults.push(promiseRes);
                }
                finally {
                    releaseFns.forEach((releaseFn) => setTimeout(releaseFn, 10 * 1000)); // 10 seconds per 20 joined channels.
                }
            }
            return promiseResults.reduce((acc, obj) => ({ ...acc, ...obj }), {});
        };
        (0, apply_function_replacements_1.applyReplacements)(this, client, {
            join: joinReplacement,
            joinAll: joinAllReplacement,
        });
    }
    async acquire() {
        const releaseFn = () => {
            this.joinLimitsSemaphore.release();
        };
        await this.joinLimitsSemaphore.acquire();
        return releaseFn;
    }
}
exports.JoinRateLimiter = JoinRateLimiter;
//# sourceMappingURL=join.js.map